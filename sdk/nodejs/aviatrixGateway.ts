// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class AviatrixGateway extends pulumi.CustomResource {
    /**
     * Get an existing AviatrixGateway resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: AviatrixGatewayState, opts?: pulumi.CustomResourceOptions): AviatrixGateway {
        return new AviatrixGateway(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'aviatrix:index/aviatrixGateway:AviatrixGateway';

    /**
     * Returns true if the given object is an instance of AviatrixGateway.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is AviatrixGateway {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === AviatrixGateway.__pulumiType;
    }

    /**
     * Account name. This account will be used to launch Aviatrix gateway.
     */
    public readonly accountName!: pulumi.Output<string>;
    /**
     * A list of destination CIDR ranges that will also go through the VPN tunnel when Split Tunnel Mode is enabled.
     */
    public readonly additionalCidrs!: pulumi.Output<string | undefined>;
    /**
     * A list of CIDR ranges separated by comma to configure when 'designated_gateway' feature is enabled.
     */
    public readonly additionalCidrsDesignatedGateway!: pulumi.Output<string | undefined>;
    /**
     * When value is false, reuse an idle address in Elastic IP pool for this gateway. Otherwise, allocate a new Elastic IP and
     * use it for this gateway.
     */
    public readonly allocateNewEip!: pulumi.Output<boolean | undefined>;
    /**
     * Availability domain for OCI.
     */
    public readonly availabilityDomain!: pulumi.Output<string>;
    /**
     * The name of the public IP address and its resource group in Azure to assign to this Gateway.
     */
    public readonly azureEipNameResourceGroup!: pulumi.Output<string>;
    /**
     * Instance ID of the gateway.
     */
    public /*out*/ readonly cloudInstanceId!: pulumi.Output<string>;
    /**
     * Type of cloud service provider.
     */
    public readonly cloudType!: pulumi.Output<number>;
    /**
     * Customer managed key ID.
     */
    public readonly customerManagedKeys!: pulumi.Output<string | undefined>;
    /**
     * API hostname for DUO auth mode.
     */
    public readonly duoApiHostname!: pulumi.Output<string | undefined>;
    /**
     * Integration key for DUO auth mode.
     */
    public readonly duoIntegrationKey!: pulumi.Output<string | undefined>;
    /**
     * Push mode for DUO auth.
     */
    public readonly duoPushMode!: pulumi.Output<string | undefined>;
    /**
     * Secret key for DUO auth mode.
     */
    public readonly duoSecretKey!: pulumi.Output<string | undefined>;
    /**
     * Required when allocate_new_eip is false. It uses specified EIP for this gateway.
     */
    public readonly eip!: pulumi.Output<string>;
    /**
     * ELB DNS Name.
     */
    public /*out*/ readonly elbDnsName!: pulumi.Output<string>;
    /**
     * A name for the ELB that is created.
     */
    public readonly elbName!: pulumi.Output<string>;
    /**
     * Enable 'designated_gateway' feature for Gateway. Valid values: true, false.
     */
    public readonly enableDesignatedGateway!: pulumi.Output<boolean | undefined>;
    /**
     * Specify whether to enable ELB or not.
     */
    public readonly enableElb!: pulumi.Output<boolean | undefined>;
    /**
     * Enable encrypt gateway EBS volume. Only supported for AWS provider. Valid values: true, false. Default value: false.
     */
    public readonly enableEncryptVolume!: pulumi.Output<boolean | undefined>;
    /**
     * Enable jumbo frame support for Gateway. Valid values: true or false. Default value: true.
     */
    public readonly enableJumboFrame!: pulumi.Output<boolean | undefined>;
    /**
     * Specify whether to enable LDAP or not. Supported values: 'yes' and 'no'.
     */
    public readonly enableLdap!: pulumi.Output<boolean | undefined>;
    /**
     * Enable monitor gateway subnets. Valid values: true, false. Default value: false.
     */
    public readonly enableMonitorGatewaySubnets!: pulumi.Output<boolean | undefined>;
    /**
     * Create a [Public Subnet Filtering gateway](https://docs.aviatrix.com/HowTos/public_subnet_filtering_faq.html).
     */
    public readonly enablePublicSubnetFiltering!: pulumi.Output<boolean | undefined>;
    /**
     * Enable spot instance. NOT supported for production deployment.
     */
    public readonly enableSpotInstance!: pulumi.Output<boolean | undefined>;
    /**
     * Enable vpc_dns_server for Gateway. Valid values: true, false.
     */
    public readonly enableVpcDnsServer!: pulumi.Output<boolean | undefined>;
    /**
     * This field indicates whether to enable VPN NAT or not. Only supported for VPN gateway. Valid values: true, false.
     * Default value: true.
     */
    public readonly enableVpnNat!: pulumi.Output<boolean | undefined>;
    /**
     * Fault domain for OCI.
     */
    public readonly faultDomain!: pulumi.Output<string>;
    /**
     * FQDN gateway lan interface cidr.
     */
    public readonly fqdnLanCidr!: pulumi.Output<string | undefined>;
    /**
     * FQDN gateway lan interface id.
     */
    public /*out*/ readonly fqdnLanInterface!: pulumi.Output<string>;
    /**
     * LAN VPC ID. Only used for GCP FQDN Gateway.
     */
    public readonly fqdnLanVpcId!: pulumi.Output<string | undefined>;
    /**
     * Aviatrix gateway unique name.
     */
    public readonly gwName!: pulumi.Output<string>;
    /**
     * Size of Gateway Instance.
     */
    public readonly gwSize!: pulumi.Output<string>;
    /**
     * Typed value when modifying idle_timeout. If it's -1, this feature is disabled.
     */
    public readonly idleTimeout!: pulumi.Output<number | undefined>;
    /**
     * image_version can be used to set the desired image version of the gateway. If set, we will attempt to update the gateway
     * to the specified version.
     */
    public readonly imageVersion!: pulumi.Output<string>;
    /**
     * Enable Insane Mode for Gateway. Valid values: true, false.
     */
    public readonly insaneMode!: pulumi.Output<boolean | undefined>;
    /**
     * AZ of subnet being created for Insane Mode Gateway. Required if insane_mode is set.
     */
    public readonly insaneModeAz!: pulumi.Output<string | undefined>;
    /**
     * LDAP base DN. Required: Yes if enable_ldap is 'yes'.
     */
    public readonly ldapBaseDn!: pulumi.Output<string | undefined>;
    /**
     * LDAP bind DN. Required: Yes if enable_ldap is 'yes'.
     */
    public readonly ldapBindDn!: pulumi.Output<string | undefined>;
    /**
     * LDAP password. Required: Yes if enable_ldap is 'yes'.
     */
    public readonly ldapPassword!: pulumi.Output<string | undefined>;
    /**
     * LDAP server address. Required: Yes if enable_ldap is 'yes'.
     */
    public readonly ldapServer!: pulumi.Output<string | undefined>;
    /**
     * LDAP user attribute. Required: Yes if enable_ldap is 'yes'.
     */
    public readonly ldapUsernameAttribute!: pulumi.Output<string | undefined>;
    /**
     * Maximum connection of VPN access.
     */
    public readonly maxVpnConn!: pulumi.Output<string | undefined>;
    /**
     * A set of monitored instance ids. Only valid when 'enable_monitor_gateway_subnets' = true.
     */
    public readonly monitorExcludeLists!: pulumi.Output<string[] | undefined>;
    /**
     * A list of DNS servers used to resolve domain names by a connected VPN user when Split Tunnel Mode is enabled.
     */
    public readonly nameServers!: pulumi.Output<string | undefined>;
    /**
     * Token for Okta auth mode.
     */
    public readonly oktaToken!: pulumi.Output<string | undefined>;
    /**
     * URL for Okta auth mode.
     */
    public readonly oktaUrl!: pulumi.Output<string | undefined>;
    /**
     * Username suffix for Okta auth mode.
     */
    public readonly oktaUsernameSuffix!: pulumi.Output<string | undefined>;
    /**
     * Two step authentication mode.
     */
    public readonly otpMode!: pulumi.Output<string | undefined>;
    /**
     * Peering HA availability domain for OCI.
     */
    public readonly peeringHaAvailabilityDomain!: pulumi.Output<string>;
    /**
     * The name of the public IP address and its resource group in Azure to assign to the Peering HA Gateway.
     */
    public readonly peeringHaAzureEipNameResourceGroup!: pulumi.Output<string>;
    /**
     * Instance ID of the peering HA gateway.
     */
    public /*out*/ readonly peeringHaCloudInstanceId!: pulumi.Output<string>;
    /**
     * Public IP address that you want assigned to the HA peering instance.
     */
    public readonly peeringHaEip!: pulumi.Output<string>;
    /**
     * Peering HA fault domain for OCI.
     */
    public readonly peeringHaFaultDomain!: pulumi.Output<string>;
    /**
     * Aviatrix gateway unique name of HA gateway.
     */
    public /*out*/ readonly peeringHaGwName!: pulumi.Output<string>;
    /**
     * Peering HA Gateway Size.
     */
    public readonly peeringHaGwSize!: pulumi.Output<string | undefined>;
    /**
     * peering_ha_image_version can be used to set the desired image version of the HA gateway. If set, we will attempt to
     * update the gateway to the specified version.
     */
    public readonly peeringHaImageVersion!: pulumi.Output<string>;
    /**
     * AZ of subnet being created for Insane Mode Peering HA Gateway. Required if insane_mode is set.
     */
    public readonly peeringHaInsaneModeAz!: pulumi.Output<string | undefined>;
    /**
     * Private IP address of HA gateway.
     */
    public /*out*/ readonly peeringHaPrivateIp!: pulumi.Output<string>;
    /**
     * Peering HA security group used for the gateway.
     */
    public /*out*/ readonly peeringHaSecurityGroupId!: pulumi.Output<string>;
    /**
     * peering_ha_software_version can be used to set the desired software version of the HA gateway. If set, we will attempt
     * to update the gateway to the specified version. If left blank, the gateway software version will continue to be managed
     * through the aviatrix_controller_config resource.
     */
    public readonly peeringHaSoftwareVersion!: pulumi.Output<string>;
    /**
     * Public Subnet Information while creating Peering HA Gateway, only subnet is accepted. Required to create peering ha
     * gateway if cloud_type = 1 or 8 (AWS or Azure). Optional if cloud_type = 4 (GCP)
     */
    public readonly peeringHaSubnet!: pulumi.Output<string | undefined>;
    /**
     * Zone information for creating Peering HA Gateway. Required to create peering ha gateway if cloud_type = 4 (GCP).
     * Optional for cloud_type = 8 (Azure).
     */
    public readonly peeringHaZone!: pulumi.Output<string | undefined>;
    /**
     * Private IP address of the Gateway created.
     */
    public /*out*/ readonly privateIp!: pulumi.Output<string>;
    /**
     * NS server used by the gateway.
     */
    public /*out*/ readonly publicDnsServer!: pulumi.Output<string>;
    /**
     * Whether to enforce Guard Duty IP blocking. Required when `enable_public_subnet_filtering` attribute is true. Valid
     * values: true or false. Default value: true.
     */
    public readonly publicSubnetFilteringGuardDutyEnforced!: pulumi.Output<boolean | undefined>;
    /**
     * Route tables whose associated public subnets are protected for the HA PSF gateway. Required when
     * enable_public_subnet_filtering and peering_ha_subnet are set.
     */
    public readonly publicSubnetFilteringHaRouteTables!: pulumi.Output<string[] | undefined>;
    /**
     * Route tables whose associated public subnets are protected. Required when `enable_public_subnet_filtering` attribute is
     * true.
     */
    public readonly publicSubnetFilteringRouteTables!: pulumi.Output<string[] | undefined>;
    /**
     * Typed value when modifying renegotiation_interval. If it's -1, this feature is disabled.
     */
    public readonly renegotiationInterval!: pulumi.Output<number | undefined>;
    /**
     * Gateway ethernet interface RX queue size. Supported for AWS related clouds only.
     */
    public readonly rxQueueSize!: pulumi.Output<string | undefined>;
    /**
     * This field indicates whether to enable SAML or not.
     */
    public readonly samlEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * A list of domain names that will use the NameServer when a specific name is not in the destination when Split Tunnel
     * Mode is enabled.
     */
    public readonly searchDomains!: pulumi.Output<string | undefined>;
    /**
     * Security group used for the gateway.
     */
    public /*out*/ readonly securityGroupId!: pulumi.Output<string>;
    /**
     * Set to true if this feature is desired.
     */
    public readonly singleAzHa!: pulumi.Output<boolean | undefined>;
    /**
     * Enable Source NAT for this container.
     */
    public readonly singleIpSnat!: pulumi.Output<boolean | undefined>;
    /**
     * software_version can be used to set the desired software version of the gateway. If set, we will attempt to update the
     * gateway to the specified version. If left blank, the gateway software version will continue to be managed through the
     * aviatrix_controller_config resource.
     */
    public readonly softwareVersion!: pulumi.Output<string>;
    /**
     * Specify split tunnel mode.
     */
    public readonly splitTunnel!: pulumi.Output<boolean | undefined>;
    /**
     * Price for spot instance. NOT supported for production deployment.
     */
    public readonly spotPrice!: pulumi.Output<string | undefined>;
    /**
     * A VPC Network address range selected from one of the available network ranges.
     */
    public readonly subnet!: pulumi.Output<string>;
    /**
     * Instance tag of cloud provider.
     *
     * @deprecated Use tags instead.
     */
    public readonly tagLists!: pulumi.Output<string[] | undefined>;
    /**
     * A map of tags to assign to the gateway.
     */
    public readonly tags!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The IPSec tunnel down detection time for the Gateway.
     */
    public readonly tunnelDetectionTime!: pulumi.Output<number>;
    /**
     * ID of legacy VPC/Vnet to be connected.
     */
    public readonly vpcId!: pulumi.Output<string>;
    /**
     * Region where this gateway will be launched.
     */
    public readonly vpcReg!: pulumi.Output<string>;
    /**
     * Enable user access through VPN to this container.
     */
    public readonly vpnAccess!: pulumi.Output<boolean | undefined>;
    /**
     * VPN CIDR block for the container.
     */
    public readonly vpnCidr!: pulumi.Output<string | undefined>;
    /**
     * Elb protocol for VPN gateway with elb enabled. Only supports AWS provider. Valid values: 'TCP', 'UDP'. If not specified,
     * 'TCP'' will be used.
     */
    public readonly vpnProtocol!: pulumi.Output<string>;
    /**
     * Availability Zone. Only available for Azure and Public Subnet Filtering gateway
     */
    public readonly zone!: pulumi.Output<string | undefined>;

    /**
     * Create a AviatrixGateway resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: AviatrixGatewayArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: AviatrixGatewayArgs | AviatrixGatewayState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as AviatrixGatewayState | undefined;
            resourceInputs["accountName"] = state ? state.accountName : undefined;
            resourceInputs["additionalCidrs"] = state ? state.additionalCidrs : undefined;
            resourceInputs["additionalCidrsDesignatedGateway"] = state ? state.additionalCidrsDesignatedGateway : undefined;
            resourceInputs["allocateNewEip"] = state ? state.allocateNewEip : undefined;
            resourceInputs["availabilityDomain"] = state ? state.availabilityDomain : undefined;
            resourceInputs["azureEipNameResourceGroup"] = state ? state.azureEipNameResourceGroup : undefined;
            resourceInputs["cloudInstanceId"] = state ? state.cloudInstanceId : undefined;
            resourceInputs["cloudType"] = state ? state.cloudType : undefined;
            resourceInputs["customerManagedKeys"] = state ? state.customerManagedKeys : undefined;
            resourceInputs["duoApiHostname"] = state ? state.duoApiHostname : undefined;
            resourceInputs["duoIntegrationKey"] = state ? state.duoIntegrationKey : undefined;
            resourceInputs["duoPushMode"] = state ? state.duoPushMode : undefined;
            resourceInputs["duoSecretKey"] = state ? state.duoSecretKey : undefined;
            resourceInputs["eip"] = state ? state.eip : undefined;
            resourceInputs["elbDnsName"] = state ? state.elbDnsName : undefined;
            resourceInputs["elbName"] = state ? state.elbName : undefined;
            resourceInputs["enableDesignatedGateway"] = state ? state.enableDesignatedGateway : undefined;
            resourceInputs["enableElb"] = state ? state.enableElb : undefined;
            resourceInputs["enableEncryptVolume"] = state ? state.enableEncryptVolume : undefined;
            resourceInputs["enableJumboFrame"] = state ? state.enableJumboFrame : undefined;
            resourceInputs["enableLdap"] = state ? state.enableLdap : undefined;
            resourceInputs["enableMonitorGatewaySubnets"] = state ? state.enableMonitorGatewaySubnets : undefined;
            resourceInputs["enablePublicSubnetFiltering"] = state ? state.enablePublicSubnetFiltering : undefined;
            resourceInputs["enableSpotInstance"] = state ? state.enableSpotInstance : undefined;
            resourceInputs["enableVpcDnsServer"] = state ? state.enableVpcDnsServer : undefined;
            resourceInputs["enableVpnNat"] = state ? state.enableVpnNat : undefined;
            resourceInputs["faultDomain"] = state ? state.faultDomain : undefined;
            resourceInputs["fqdnLanCidr"] = state ? state.fqdnLanCidr : undefined;
            resourceInputs["fqdnLanInterface"] = state ? state.fqdnLanInterface : undefined;
            resourceInputs["fqdnLanVpcId"] = state ? state.fqdnLanVpcId : undefined;
            resourceInputs["gwName"] = state ? state.gwName : undefined;
            resourceInputs["gwSize"] = state ? state.gwSize : undefined;
            resourceInputs["idleTimeout"] = state ? state.idleTimeout : undefined;
            resourceInputs["imageVersion"] = state ? state.imageVersion : undefined;
            resourceInputs["insaneMode"] = state ? state.insaneMode : undefined;
            resourceInputs["insaneModeAz"] = state ? state.insaneModeAz : undefined;
            resourceInputs["ldapBaseDn"] = state ? state.ldapBaseDn : undefined;
            resourceInputs["ldapBindDn"] = state ? state.ldapBindDn : undefined;
            resourceInputs["ldapPassword"] = state ? state.ldapPassword : undefined;
            resourceInputs["ldapServer"] = state ? state.ldapServer : undefined;
            resourceInputs["ldapUsernameAttribute"] = state ? state.ldapUsernameAttribute : undefined;
            resourceInputs["maxVpnConn"] = state ? state.maxVpnConn : undefined;
            resourceInputs["monitorExcludeLists"] = state ? state.monitorExcludeLists : undefined;
            resourceInputs["nameServers"] = state ? state.nameServers : undefined;
            resourceInputs["oktaToken"] = state ? state.oktaToken : undefined;
            resourceInputs["oktaUrl"] = state ? state.oktaUrl : undefined;
            resourceInputs["oktaUsernameSuffix"] = state ? state.oktaUsernameSuffix : undefined;
            resourceInputs["otpMode"] = state ? state.otpMode : undefined;
            resourceInputs["peeringHaAvailabilityDomain"] = state ? state.peeringHaAvailabilityDomain : undefined;
            resourceInputs["peeringHaAzureEipNameResourceGroup"] = state ? state.peeringHaAzureEipNameResourceGroup : undefined;
            resourceInputs["peeringHaCloudInstanceId"] = state ? state.peeringHaCloudInstanceId : undefined;
            resourceInputs["peeringHaEip"] = state ? state.peeringHaEip : undefined;
            resourceInputs["peeringHaFaultDomain"] = state ? state.peeringHaFaultDomain : undefined;
            resourceInputs["peeringHaGwName"] = state ? state.peeringHaGwName : undefined;
            resourceInputs["peeringHaGwSize"] = state ? state.peeringHaGwSize : undefined;
            resourceInputs["peeringHaImageVersion"] = state ? state.peeringHaImageVersion : undefined;
            resourceInputs["peeringHaInsaneModeAz"] = state ? state.peeringHaInsaneModeAz : undefined;
            resourceInputs["peeringHaPrivateIp"] = state ? state.peeringHaPrivateIp : undefined;
            resourceInputs["peeringHaSecurityGroupId"] = state ? state.peeringHaSecurityGroupId : undefined;
            resourceInputs["peeringHaSoftwareVersion"] = state ? state.peeringHaSoftwareVersion : undefined;
            resourceInputs["peeringHaSubnet"] = state ? state.peeringHaSubnet : undefined;
            resourceInputs["peeringHaZone"] = state ? state.peeringHaZone : undefined;
            resourceInputs["privateIp"] = state ? state.privateIp : undefined;
            resourceInputs["publicDnsServer"] = state ? state.publicDnsServer : undefined;
            resourceInputs["publicSubnetFilteringGuardDutyEnforced"] = state ? state.publicSubnetFilteringGuardDutyEnforced : undefined;
            resourceInputs["publicSubnetFilteringHaRouteTables"] = state ? state.publicSubnetFilteringHaRouteTables : undefined;
            resourceInputs["publicSubnetFilteringRouteTables"] = state ? state.publicSubnetFilteringRouteTables : undefined;
            resourceInputs["renegotiationInterval"] = state ? state.renegotiationInterval : undefined;
            resourceInputs["rxQueueSize"] = state ? state.rxQueueSize : undefined;
            resourceInputs["samlEnabled"] = state ? state.samlEnabled : undefined;
            resourceInputs["searchDomains"] = state ? state.searchDomains : undefined;
            resourceInputs["securityGroupId"] = state ? state.securityGroupId : undefined;
            resourceInputs["singleAzHa"] = state ? state.singleAzHa : undefined;
            resourceInputs["singleIpSnat"] = state ? state.singleIpSnat : undefined;
            resourceInputs["softwareVersion"] = state ? state.softwareVersion : undefined;
            resourceInputs["splitTunnel"] = state ? state.splitTunnel : undefined;
            resourceInputs["spotPrice"] = state ? state.spotPrice : undefined;
            resourceInputs["subnet"] = state ? state.subnet : undefined;
            resourceInputs["tagLists"] = state ? state.tagLists : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["tunnelDetectionTime"] = state ? state.tunnelDetectionTime : undefined;
            resourceInputs["vpcId"] = state ? state.vpcId : undefined;
            resourceInputs["vpcReg"] = state ? state.vpcReg : undefined;
            resourceInputs["vpnAccess"] = state ? state.vpnAccess : undefined;
            resourceInputs["vpnCidr"] = state ? state.vpnCidr : undefined;
            resourceInputs["vpnProtocol"] = state ? state.vpnProtocol : undefined;
            resourceInputs["zone"] = state ? state.zone : undefined;
        } else {
            const args = argsOrState as AviatrixGatewayArgs | undefined;
            if ((!args || args.accountName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'accountName'");
            }
            if ((!args || args.cloudType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'cloudType'");
            }
            if ((!args || args.gwName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'gwName'");
            }
            if ((!args || args.gwSize === undefined) && !opts.urn) {
                throw new Error("Missing required property 'gwSize'");
            }
            if ((!args || args.subnet === undefined) && !opts.urn) {
                throw new Error("Missing required property 'subnet'");
            }
            if ((!args || args.vpcId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'vpcId'");
            }
            if ((!args || args.vpcReg === undefined) && !opts.urn) {
                throw new Error("Missing required property 'vpcReg'");
            }
            resourceInputs["accountName"] = args ? args.accountName : undefined;
            resourceInputs["additionalCidrs"] = args ? args.additionalCidrs : undefined;
            resourceInputs["additionalCidrsDesignatedGateway"] = args ? args.additionalCidrsDesignatedGateway : undefined;
            resourceInputs["allocateNewEip"] = args ? args.allocateNewEip : undefined;
            resourceInputs["availabilityDomain"] = args ? args.availabilityDomain : undefined;
            resourceInputs["azureEipNameResourceGroup"] = args ? args.azureEipNameResourceGroup : undefined;
            resourceInputs["cloudType"] = args ? args.cloudType : undefined;
            resourceInputs["customerManagedKeys"] = args ? args.customerManagedKeys : undefined;
            resourceInputs["duoApiHostname"] = args ? args.duoApiHostname : undefined;
            resourceInputs["duoIntegrationKey"] = args ? args.duoIntegrationKey : undefined;
            resourceInputs["duoPushMode"] = args ? args.duoPushMode : undefined;
            resourceInputs["duoSecretKey"] = args ? args.duoSecretKey : undefined;
            resourceInputs["eip"] = args ? args.eip : undefined;
            resourceInputs["elbName"] = args ? args.elbName : undefined;
            resourceInputs["enableDesignatedGateway"] = args ? args.enableDesignatedGateway : undefined;
            resourceInputs["enableElb"] = args ? args.enableElb : undefined;
            resourceInputs["enableEncryptVolume"] = args ? args.enableEncryptVolume : undefined;
            resourceInputs["enableJumboFrame"] = args ? args.enableJumboFrame : undefined;
            resourceInputs["enableLdap"] = args ? args.enableLdap : undefined;
            resourceInputs["enableMonitorGatewaySubnets"] = args ? args.enableMonitorGatewaySubnets : undefined;
            resourceInputs["enablePublicSubnetFiltering"] = args ? args.enablePublicSubnetFiltering : undefined;
            resourceInputs["enableSpotInstance"] = args ? args.enableSpotInstance : undefined;
            resourceInputs["enableVpcDnsServer"] = args ? args.enableVpcDnsServer : undefined;
            resourceInputs["enableVpnNat"] = args ? args.enableVpnNat : undefined;
            resourceInputs["faultDomain"] = args ? args.faultDomain : undefined;
            resourceInputs["fqdnLanCidr"] = args ? args.fqdnLanCidr : undefined;
            resourceInputs["fqdnLanVpcId"] = args ? args.fqdnLanVpcId : undefined;
            resourceInputs["gwName"] = args ? args.gwName : undefined;
            resourceInputs["gwSize"] = args ? args.gwSize : undefined;
            resourceInputs["idleTimeout"] = args ? args.idleTimeout : undefined;
            resourceInputs["imageVersion"] = args ? args.imageVersion : undefined;
            resourceInputs["insaneMode"] = args ? args.insaneMode : undefined;
            resourceInputs["insaneModeAz"] = args ? args.insaneModeAz : undefined;
            resourceInputs["ldapBaseDn"] = args ? args.ldapBaseDn : undefined;
            resourceInputs["ldapBindDn"] = args ? args.ldapBindDn : undefined;
            resourceInputs["ldapPassword"] = args ? args.ldapPassword : undefined;
            resourceInputs["ldapServer"] = args ? args.ldapServer : undefined;
            resourceInputs["ldapUsernameAttribute"] = args ? args.ldapUsernameAttribute : undefined;
            resourceInputs["maxVpnConn"] = args ? args.maxVpnConn : undefined;
            resourceInputs["monitorExcludeLists"] = args ? args.monitorExcludeLists : undefined;
            resourceInputs["nameServers"] = args ? args.nameServers : undefined;
            resourceInputs["oktaToken"] = args ? args.oktaToken : undefined;
            resourceInputs["oktaUrl"] = args ? args.oktaUrl : undefined;
            resourceInputs["oktaUsernameSuffix"] = args ? args.oktaUsernameSuffix : undefined;
            resourceInputs["otpMode"] = args ? args.otpMode : undefined;
            resourceInputs["peeringHaAvailabilityDomain"] = args ? args.peeringHaAvailabilityDomain : undefined;
            resourceInputs["peeringHaAzureEipNameResourceGroup"] = args ? args.peeringHaAzureEipNameResourceGroup : undefined;
            resourceInputs["peeringHaEip"] = args ? args.peeringHaEip : undefined;
            resourceInputs["peeringHaFaultDomain"] = args ? args.peeringHaFaultDomain : undefined;
            resourceInputs["peeringHaGwSize"] = args ? args.peeringHaGwSize : undefined;
            resourceInputs["peeringHaImageVersion"] = args ? args.peeringHaImageVersion : undefined;
            resourceInputs["peeringHaInsaneModeAz"] = args ? args.peeringHaInsaneModeAz : undefined;
            resourceInputs["peeringHaSoftwareVersion"] = args ? args.peeringHaSoftwareVersion : undefined;
            resourceInputs["peeringHaSubnet"] = args ? args.peeringHaSubnet : undefined;
            resourceInputs["peeringHaZone"] = args ? args.peeringHaZone : undefined;
            resourceInputs["publicSubnetFilteringGuardDutyEnforced"] = args ? args.publicSubnetFilteringGuardDutyEnforced : undefined;
            resourceInputs["publicSubnetFilteringHaRouteTables"] = args ? args.publicSubnetFilteringHaRouteTables : undefined;
            resourceInputs["publicSubnetFilteringRouteTables"] = args ? args.publicSubnetFilteringRouteTables : undefined;
            resourceInputs["renegotiationInterval"] = args ? args.renegotiationInterval : undefined;
            resourceInputs["rxQueueSize"] = args ? args.rxQueueSize : undefined;
            resourceInputs["samlEnabled"] = args ? args.samlEnabled : undefined;
            resourceInputs["searchDomains"] = args ? args.searchDomains : undefined;
            resourceInputs["singleAzHa"] = args ? args.singleAzHa : undefined;
            resourceInputs["singleIpSnat"] = args ? args.singleIpSnat : undefined;
            resourceInputs["softwareVersion"] = args ? args.softwareVersion : undefined;
            resourceInputs["splitTunnel"] = args ? args.splitTunnel : undefined;
            resourceInputs["spotPrice"] = args ? args.spotPrice : undefined;
            resourceInputs["subnet"] = args ? args.subnet : undefined;
            resourceInputs["tagLists"] = args ? args.tagLists : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["tunnelDetectionTime"] = args ? args.tunnelDetectionTime : undefined;
            resourceInputs["vpcId"] = args ? args.vpcId : undefined;
            resourceInputs["vpcReg"] = args ? args.vpcReg : undefined;
            resourceInputs["vpnAccess"] = args ? args.vpnAccess : undefined;
            resourceInputs["vpnCidr"] = args ? args.vpnCidr : undefined;
            resourceInputs["vpnProtocol"] = args ? args.vpnProtocol : undefined;
            resourceInputs["zone"] = args ? args.zone : undefined;
            resourceInputs["cloudInstanceId"] = undefined /*out*/;
            resourceInputs["elbDnsName"] = undefined /*out*/;
            resourceInputs["fqdnLanInterface"] = undefined /*out*/;
            resourceInputs["peeringHaCloudInstanceId"] = undefined /*out*/;
            resourceInputs["peeringHaGwName"] = undefined /*out*/;
            resourceInputs["peeringHaPrivateIp"] = undefined /*out*/;
            resourceInputs["peeringHaSecurityGroupId"] = undefined /*out*/;
            resourceInputs["privateIp"] = undefined /*out*/;
            resourceInputs["publicDnsServer"] = undefined /*out*/;
            resourceInputs["securityGroupId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(AviatrixGateway.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering AviatrixGateway resources.
 */
export interface AviatrixGatewayState {
    /**
     * Account name. This account will be used to launch Aviatrix gateway.
     */
    accountName?: pulumi.Input<string>;
    /**
     * A list of destination CIDR ranges that will also go through the VPN tunnel when Split Tunnel Mode is enabled.
     */
    additionalCidrs?: pulumi.Input<string>;
    /**
     * A list of CIDR ranges separated by comma to configure when 'designated_gateway' feature is enabled.
     */
    additionalCidrsDesignatedGateway?: pulumi.Input<string>;
    /**
     * When value is false, reuse an idle address in Elastic IP pool for this gateway. Otherwise, allocate a new Elastic IP and
     * use it for this gateway.
     */
    allocateNewEip?: pulumi.Input<boolean>;
    /**
     * Availability domain for OCI.
     */
    availabilityDomain?: pulumi.Input<string>;
    /**
     * The name of the public IP address and its resource group in Azure to assign to this Gateway.
     */
    azureEipNameResourceGroup?: pulumi.Input<string>;
    /**
     * Instance ID of the gateway.
     */
    cloudInstanceId?: pulumi.Input<string>;
    /**
     * Type of cloud service provider.
     */
    cloudType?: pulumi.Input<number>;
    /**
     * Customer managed key ID.
     */
    customerManagedKeys?: pulumi.Input<string>;
    /**
     * API hostname for DUO auth mode.
     */
    duoApiHostname?: pulumi.Input<string>;
    /**
     * Integration key for DUO auth mode.
     */
    duoIntegrationKey?: pulumi.Input<string>;
    /**
     * Push mode for DUO auth.
     */
    duoPushMode?: pulumi.Input<string>;
    /**
     * Secret key for DUO auth mode.
     */
    duoSecretKey?: pulumi.Input<string>;
    /**
     * Required when allocate_new_eip is false. It uses specified EIP for this gateway.
     */
    eip?: pulumi.Input<string>;
    /**
     * ELB DNS Name.
     */
    elbDnsName?: pulumi.Input<string>;
    /**
     * A name for the ELB that is created.
     */
    elbName?: pulumi.Input<string>;
    /**
     * Enable 'designated_gateway' feature for Gateway. Valid values: true, false.
     */
    enableDesignatedGateway?: pulumi.Input<boolean>;
    /**
     * Specify whether to enable ELB or not.
     */
    enableElb?: pulumi.Input<boolean>;
    /**
     * Enable encrypt gateway EBS volume. Only supported for AWS provider. Valid values: true, false. Default value: false.
     */
    enableEncryptVolume?: pulumi.Input<boolean>;
    /**
     * Enable jumbo frame support for Gateway. Valid values: true or false. Default value: true.
     */
    enableJumboFrame?: pulumi.Input<boolean>;
    /**
     * Specify whether to enable LDAP or not. Supported values: 'yes' and 'no'.
     */
    enableLdap?: pulumi.Input<boolean>;
    /**
     * Enable monitor gateway subnets. Valid values: true, false. Default value: false.
     */
    enableMonitorGatewaySubnets?: pulumi.Input<boolean>;
    /**
     * Create a [Public Subnet Filtering gateway](https://docs.aviatrix.com/HowTos/public_subnet_filtering_faq.html).
     */
    enablePublicSubnetFiltering?: pulumi.Input<boolean>;
    /**
     * Enable spot instance. NOT supported for production deployment.
     */
    enableSpotInstance?: pulumi.Input<boolean>;
    /**
     * Enable vpc_dns_server for Gateway. Valid values: true, false.
     */
    enableVpcDnsServer?: pulumi.Input<boolean>;
    /**
     * This field indicates whether to enable VPN NAT or not. Only supported for VPN gateway. Valid values: true, false.
     * Default value: true.
     */
    enableVpnNat?: pulumi.Input<boolean>;
    /**
     * Fault domain for OCI.
     */
    faultDomain?: pulumi.Input<string>;
    /**
     * FQDN gateway lan interface cidr.
     */
    fqdnLanCidr?: pulumi.Input<string>;
    /**
     * FQDN gateway lan interface id.
     */
    fqdnLanInterface?: pulumi.Input<string>;
    /**
     * LAN VPC ID. Only used for GCP FQDN Gateway.
     */
    fqdnLanVpcId?: pulumi.Input<string>;
    /**
     * Aviatrix gateway unique name.
     */
    gwName?: pulumi.Input<string>;
    /**
     * Size of Gateway Instance.
     */
    gwSize?: pulumi.Input<string>;
    /**
     * Typed value when modifying idle_timeout. If it's -1, this feature is disabled.
     */
    idleTimeout?: pulumi.Input<number>;
    /**
     * image_version can be used to set the desired image version of the gateway. If set, we will attempt to update the gateway
     * to the specified version.
     */
    imageVersion?: pulumi.Input<string>;
    /**
     * Enable Insane Mode for Gateway. Valid values: true, false.
     */
    insaneMode?: pulumi.Input<boolean>;
    /**
     * AZ of subnet being created for Insane Mode Gateway. Required if insane_mode is set.
     */
    insaneModeAz?: pulumi.Input<string>;
    /**
     * LDAP base DN. Required: Yes if enable_ldap is 'yes'.
     */
    ldapBaseDn?: pulumi.Input<string>;
    /**
     * LDAP bind DN. Required: Yes if enable_ldap is 'yes'.
     */
    ldapBindDn?: pulumi.Input<string>;
    /**
     * LDAP password. Required: Yes if enable_ldap is 'yes'.
     */
    ldapPassword?: pulumi.Input<string>;
    /**
     * LDAP server address. Required: Yes if enable_ldap is 'yes'.
     */
    ldapServer?: pulumi.Input<string>;
    /**
     * LDAP user attribute. Required: Yes if enable_ldap is 'yes'.
     */
    ldapUsernameAttribute?: pulumi.Input<string>;
    /**
     * Maximum connection of VPN access.
     */
    maxVpnConn?: pulumi.Input<string>;
    /**
     * A set of monitored instance ids. Only valid when 'enable_monitor_gateway_subnets' = true.
     */
    monitorExcludeLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of DNS servers used to resolve domain names by a connected VPN user when Split Tunnel Mode is enabled.
     */
    nameServers?: pulumi.Input<string>;
    /**
     * Token for Okta auth mode.
     */
    oktaToken?: pulumi.Input<string>;
    /**
     * URL for Okta auth mode.
     */
    oktaUrl?: pulumi.Input<string>;
    /**
     * Username suffix for Okta auth mode.
     */
    oktaUsernameSuffix?: pulumi.Input<string>;
    /**
     * Two step authentication mode.
     */
    otpMode?: pulumi.Input<string>;
    /**
     * Peering HA availability domain for OCI.
     */
    peeringHaAvailabilityDomain?: pulumi.Input<string>;
    /**
     * The name of the public IP address and its resource group in Azure to assign to the Peering HA Gateway.
     */
    peeringHaAzureEipNameResourceGroup?: pulumi.Input<string>;
    /**
     * Instance ID of the peering HA gateway.
     */
    peeringHaCloudInstanceId?: pulumi.Input<string>;
    /**
     * Public IP address that you want assigned to the HA peering instance.
     */
    peeringHaEip?: pulumi.Input<string>;
    /**
     * Peering HA fault domain for OCI.
     */
    peeringHaFaultDomain?: pulumi.Input<string>;
    /**
     * Aviatrix gateway unique name of HA gateway.
     */
    peeringHaGwName?: pulumi.Input<string>;
    /**
     * Peering HA Gateway Size.
     */
    peeringHaGwSize?: pulumi.Input<string>;
    /**
     * peering_ha_image_version can be used to set the desired image version of the HA gateway. If set, we will attempt to
     * update the gateway to the specified version.
     */
    peeringHaImageVersion?: pulumi.Input<string>;
    /**
     * AZ of subnet being created for Insane Mode Peering HA Gateway. Required if insane_mode is set.
     */
    peeringHaInsaneModeAz?: pulumi.Input<string>;
    /**
     * Private IP address of HA gateway.
     */
    peeringHaPrivateIp?: pulumi.Input<string>;
    /**
     * Peering HA security group used for the gateway.
     */
    peeringHaSecurityGroupId?: pulumi.Input<string>;
    /**
     * peering_ha_software_version can be used to set the desired software version of the HA gateway. If set, we will attempt
     * to update the gateway to the specified version. If left blank, the gateway software version will continue to be managed
     * through the aviatrix_controller_config resource.
     */
    peeringHaSoftwareVersion?: pulumi.Input<string>;
    /**
     * Public Subnet Information while creating Peering HA Gateway, only subnet is accepted. Required to create peering ha
     * gateway if cloud_type = 1 or 8 (AWS or Azure). Optional if cloud_type = 4 (GCP)
     */
    peeringHaSubnet?: pulumi.Input<string>;
    /**
     * Zone information for creating Peering HA Gateway. Required to create peering ha gateway if cloud_type = 4 (GCP).
     * Optional for cloud_type = 8 (Azure).
     */
    peeringHaZone?: pulumi.Input<string>;
    /**
     * Private IP address of the Gateway created.
     */
    privateIp?: pulumi.Input<string>;
    /**
     * NS server used by the gateway.
     */
    publicDnsServer?: pulumi.Input<string>;
    /**
     * Whether to enforce Guard Duty IP blocking. Required when `enable_public_subnet_filtering` attribute is true. Valid
     * values: true or false. Default value: true.
     */
    publicSubnetFilteringGuardDutyEnforced?: pulumi.Input<boolean>;
    /**
     * Route tables whose associated public subnets are protected for the HA PSF gateway. Required when
     * enable_public_subnet_filtering and peering_ha_subnet are set.
     */
    publicSubnetFilteringHaRouteTables?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Route tables whose associated public subnets are protected. Required when `enable_public_subnet_filtering` attribute is
     * true.
     */
    publicSubnetFilteringRouteTables?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Typed value when modifying renegotiation_interval. If it's -1, this feature is disabled.
     */
    renegotiationInterval?: pulumi.Input<number>;
    /**
     * Gateway ethernet interface RX queue size. Supported for AWS related clouds only.
     */
    rxQueueSize?: pulumi.Input<string>;
    /**
     * This field indicates whether to enable SAML or not.
     */
    samlEnabled?: pulumi.Input<boolean>;
    /**
     * A list of domain names that will use the NameServer when a specific name is not in the destination when Split Tunnel
     * Mode is enabled.
     */
    searchDomains?: pulumi.Input<string>;
    /**
     * Security group used for the gateway.
     */
    securityGroupId?: pulumi.Input<string>;
    /**
     * Set to true if this feature is desired.
     */
    singleAzHa?: pulumi.Input<boolean>;
    /**
     * Enable Source NAT for this container.
     */
    singleIpSnat?: pulumi.Input<boolean>;
    /**
     * software_version can be used to set the desired software version of the gateway. If set, we will attempt to update the
     * gateway to the specified version. If left blank, the gateway software version will continue to be managed through the
     * aviatrix_controller_config resource.
     */
    softwareVersion?: pulumi.Input<string>;
    /**
     * Specify split tunnel mode.
     */
    splitTunnel?: pulumi.Input<boolean>;
    /**
     * Price for spot instance. NOT supported for production deployment.
     */
    spotPrice?: pulumi.Input<string>;
    /**
     * A VPC Network address range selected from one of the available network ranges.
     */
    subnet?: pulumi.Input<string>;
    /**
     * Instance tag of cloud provider.
     *
     * @deprecated Use tags instead.
     */
    tagLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A map of tags to assign to the gateway.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The IPSec tunnel down detection time for the Gateway.
     */
    tunnelDetectionTime?: pulumi.Input<number>;
    /**
     * ID of legacy VPC/Vnet to be connected.
     */
    vpcId?: pulumi.Input<string>;
    /**
     * Region where this gateway will be launched.
     */
    vpcReg?: pulumi.Input<string>;
    /**
     * Enable user access through VPN to this container.
     */
    vpnAccess?: pulumi.Input<boolean>;
    /**
     * VPN CIDR block for the container.
     */
    vpnCidr?: pulumi.Input<string>;
    /**
     * Elb protocol for VPN gateway with elb enabled. Only supports AWS provider. Valid values: 'TCP', 'UDP'. If not specified,
     * 'TCP'' will be used.
     */
    vpnProtocol?: pulumi.Input<string>;
    /**
     * Availability Zone. Only available for Azure and Public Subnet Filtering gateway
     */
    zone?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a AviatrixGateway resource.
 */
export interface AviatrixGatewayArgs {
    /**
     * Account name. This account will be used to launch Aviatrix gateway.
     */
    accountName: pulumi.Input<string>;
    /**
     * A list of destination CIDR ranges that will also go through the VPN tunnel when Split Tunnel Mode is enabled.
     */
    additionalCidrs?: pulumi.Input<string>;
    /**
     * A list of CIDR ranges separated by comma to configure when 'designated_gateway' feature is enabled.
     */
    additionalCidrsDesignatedGateway?: pulumi.Input<string>;
    /**
     * When value is false, reuse an idle address in Elastic IP pool for this gateway. Otherwise, allocate a new Elastic IP and
     * use it for this gateway.
     */
    allocateNewEip?: pulumi.Input<boolean>;
    /**
     * Availability domain for OCI.
     */
    availabilityDomain?: pulumi.Input<string>;
    /**
     * The name of the public IP address and its resource group in Azure to assign to this Gateway.
     */
    azureEipNameResourceGroup?: pulumi.Input<string>;
    /**
     * Type of cloud service provider.
     */
    cloudType: pulumi.Input<number>;
    /**
     * Customer managed key ID.
     */
    customerManagedKeys?: pulumi.Input<string>;
    /**
     * API hostname for DUO auth mode.
     */
    duoApiHostname?: pulumi.Input<string>;
    /**
     * Integration key for DUO auth mode.
     */
    duoIntegrationKey?: pulumi.Input<string>;
    /**
     * Push mode for DUO auth.
     */
    duoPushMode?: pulumi.Input<string>;
    /**
     * Secret key for DUO auth mode.
     */
    duoSecretKey?: pulumi.Input<string>;
    /**
     * Required when allocate_new_eip is false. It uses specified EIP for this gateway.
     */
    eip?: pulumi.Input<string>;
    /**
     * A name for the ELB that is created.
     */
    elbName?: pulumi.Input<string>;
    /**
     * Enable 'designated_gateway' feature for Gateway. Valid values: true, false.
     */
    enableDesignatedGateway?: pulumi.Input<boolean>;
    /**
     * Specify whether to enable ELB or not.
     */
    enableElb?: pulumi.Input<boolean>;
    /**
     * Enable encrypt gateway EBS volume. Only supported for AWS provider. Valid values: true, false. Default value: false.
     */
    enableEncryptVolume?: pulumi.Input<boolean>;
    /**
     * Enable jumbo frame support for Gateway. Valid values: true or false. Default value: true.
     */
    enableJumboFrame?: pulumi.Input<boolean>;
    /**
     * Specify whether to enable LDAP or not. Supported values: 'yes' and 'no'.
     */
    enableLdap?: pulumi.Input<boolean>;
    /**
     * Enable monitor gateway subnets. Valid values: true, false. Default value: false.
     */
    enableMonitorGatewaySubnets?: pulumi.Input<boolean>;
    /**
     * Create a [Public Subnet Filtering gateway](https://docs.aviatrix.com/HowTos/public_subnet_filtering_faq.html).
     */
    enablePublicSubnetFiltering?: pulumi.Input<boolean>;
    /**
     * Enable spot instance. NOT supported for production deployment.
     */
    enableSpotInstance?: pulumi.Input<boolean>;
    /**
     * Enable vpc_dns_server for Gateway. Valid values: true, false.
     */
    enableVpcDnsServer?: pulumi.Input<boolean>;
    /**
     * This field indicates whether to enable VPN NAT or not. Only supported for VPN gateway. Valid values: true, false.
     * Default value: true.
     */
    enableVpnNat?: pulumi.Input<boolean>;
    /**
     * Fault domain for OCI.
     */
    faultDomain?: pulumi.Input<string>;
    /**
     * FQDN gateway lan interface cidr.
     */
    fqdnLanCidr?: pulumi.Input<string>;
    /**
     * LAN VPC ID. Only used for GCP FQDN Gateway.
     */
    fqdnLanVpcId?: pulumi.Input<string>;
    /**
     * Aviatrix gateway unique name.
     */
    gwName: pulumi.Input<string>;
    /**
     * Size of Gateway Instance.
     */
    gwSize: pulumi.Input<string>;
    /**
     * Typed value when modifying idle_timeout. If it's -1, this feature is disabled.
     */
    idleTimeout?: pulumi.Input<number>;
    /**
     * image_version can be used to set the desired image version of the gateway. If set, we will attempt to update the gateway
     * to the specified version.
     */
    imageVersion?: pulumi.Input<string>;
    /**
     * Enable Insane Mode for Gateway. Valid values: true, false.
     */
    insaneMode?: pulumi.Input<boolean>;
    /**
     * AZ of subnet being created for Insane Mode Gateway. Required if insane_mode is set.
     */
    insaneModeAz?: pulumi.Input<string>;
    /**
     * LDAP base DN. Required: Yes if enable_ldap is 'yes'.
     */
    ldapBaseDn?: pulumi.Input<string>;
    /**
     * LDAP bind DN. Required: Yes if enable_ldap is 'yes'.
     */
    ldapBindDn?: pulumi.Input<string>;
    /**
     * LDAP password. Required: Yes if enable_ldap is 'yes'.
     */
    ldapPassword?: pulumi.Input<string>;
    /**
     * LDAP server address. Required: Yes if enable_ldap is 'yes'.
     */
    ldapServer?: pulumi.Input<string>;
    /**
     * LDAP user attribute. Required: Yes if enable_ldap is 'yes'.
     */
    ldapUsernameAttribute?: pulumi.Input<string>;
    /**
     * Maximum connection of VPN access.
     */
    maxVpnConn?: pulumi.Input<string>;
    /**
     * A set of monitored instance ids. Only valid when 'enable_monitor_gateway_subnets' = true.
     */
    monitorExcludeLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of DNS servers used to resolve domain names by a connected VPN user when Split Tunnel Mode is enabled.
     */
    nameServers?: pulumi.Input<string>;
    /**
     * Token for Okta auth mode.
     */
    oktaToken?: pulumi.Input<string>;
    /**
     * URL for Okta auth mode.
     */
    oktaUrl?: pulumi.Input<string>;
    /**
     * Username suffix for Okta auth mode.
     */
    oktaUsernameSuffix?: pulumi.Input<string>;
    /**
     * Two step authentication mode.
     */
    otpMode?: pulumi.Input<string>;
    /**
     * Peering HA availability domain for OCI.
     */
    peeringHaAvailabilityDomain?: pulumi.Input<string>;
    /**
     * The name of the public IP address and its resource group in Azure to assign to the Peering HA Gateway.
     */
    peeringHaAzureEipNameResourceGroup?: pulumi.Input<string>;
    /**
     * Public IP address that you want assigned to the HA peering instance.
     */
    peeringHaEip?: pulumi.Input<string>;
    /**
     * Peering HA fault domain for OCI.
     */
    peeringHaFaultDomain?: pulumi.Input<string>;
    /**
     * Peering HA Gateway Size.
     */
    peeringHaGwSize?: pulumi.Input<string>;
    /**
     * peering_ha_image_version can be used to set the desired image version of the HA gateway. If set, we will attempt to
     * update the gateway to the specified version.
     */
    peeringHaImageVersion?: pulumi.Input<string>;
    /**
     * AZ of subnet being created for Insane Mode Peering HA Gateway. Required if insane_mode is set.
     */
    peeringHaInsaneModeAz?: pulumi.Input<string>;
    /**
     * peering_ha_software_version can be used to set the desired software version of the HA gateway. If set, we will attempt
     * to update the gateway to the specified version. If left blank, the gateway software version will continue to be managed
     * through the aviatrix_controller_config resource.
     */
    peeringHaSoftwareVersion?: pulumi.Input<string>;
    /**
     * Public Subnet Information while creating Peering HA Gateway, only subnet is accepted. Required to create peering ha
     * gateway if cloud_type = 1 or 8 (AWS or Azure). Optional if cloud_type = 4 (GCP)
     */
    peeringHaSubnet?: pulumi.Input<string>;
    /**
     * Zone information for creating Peering HA Gateway. Required to create peering ha gateway if cloud_type = 4 (GCP).
     * Optional for cloud_type = 8 (Azure).
     */
    peeringHaZone?: pulumi.Input<string>;
    /**
     * Whether to enforce Guard Duty IP blocking. Required when `enable_public_subnet_filtering` attribute is true. Valid
     * values: true or false. Default value: true.
     */
    publicSubnetFilteringGuardDutyEnforced?: pulumi.Input<boolean>;
    /**
     * Route tables whose associated public subnets are protected for the HA PSF gateway. Required when
     * enable_public_subnet_filtering and peering_ha_subnet are set.
     */
    publicSubnetFilteringHaRouteTables?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Route tables whose associated public subnets are protected. Required when `enable_public_subnet_filtering` attribute is
     * true.
     */
    publicSubnetFilteringRouteTables?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Typed value when modifying renegotiation_interval. If it's -1, this feature is disabled.
     */
    renegotiationInterval?: pulumi.Input<number>;
    /**
     * Gateway ethernet interface RX queue size. Supported for AWS related clouds only.
     */
    rxQueueSize?: pulumi.Input<string>;
    /**
     * This field indicates whether to enable SAML or not.
     */
    samlEnabled?: pulumi.Input<boolean>;
    /**
     * A list of domain names that will use the NameServer when a specific name is not in the destination when Split Tunnel
     * Mode is enabled.
     */
    searchDomains?: pulumi.Input<string>;
    /**
     * Set to true if this feature is desired.
     */
    singleAzHa?: pulumi.Input<boolean>;
    /**
     * Enable Source NAT for this container.
     */
    singleIpSnat?: pulumi.Input<boolean>;
    /**
     * software_version can be used to set the desired software version of the gateway. If set, we will attempt to update the
     * gateway to the specified version. If left blank, the gateway software version will continue to be managed through the
     * aviatrix_controller_config resource.
     */
    softwareVersion?: pulumi.Input<string>;
    /**
     * Specify split tunnel mode.
     */
    splitTunnel?: pulumi.Input<boolean>;
    /**
     * Price for spot instance. NOT supported for production deployment.
     */
    spotPrice?: pulumi.Input<string>;
    /**
     * A VPC Network address range selected from one of the available network ranges.
     */
    subnet: pulumi.Input<string>;
    /**
     * Instance tag of cloud provider.
     *
     * @deprecated Use tags instead.
     */
    tagLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A map of tags to assign to the gateway.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The IPSec tunnel down detection time for the Gateway.
     */
    tunnelDetectionTime?: pulumi.Input<number>;
    /**
     * ID of legacy VPC/Vnet to be connected.
     */
    vpcId: pulumi.Input<string>;
    /**
     * Region where this gateway will be launched.
     */
    vpcReg: pulumi.Input<string>;
    /**
     * Enable user access through VPN to this container.
     */
    vpnAccess?: pulumi.Input<boolean>;
    /**
     * VPN CIDR block for the container.
     */
    vpnCidr?: pulumi.Input<string>;
    /**
     * Elb protocol for VPN gateway with elb enabled. Only supports AWS provider. Valid values: 'TCP', 'UDP'. If not specified,
     * 'TCP'' will be used.
     */
    vpnProtocol?: pulumi.Input<string>;
    /**
     * Availability Zone. Only available for Azure and Public Subnet Filtering gateway
     */
    zone?: pulumi.Input<string>;
}
